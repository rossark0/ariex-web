import { NextRequest, NextResponse } from 'next/server';
import { OpenAI } from 'openai';
import type { ChatCompletionMessageParam } from 'openai/resources/chat/completions';

// ─── Types ────────────────────────────────────────────────────────────────

interface ChatRequestBody {
  messages: Array<{ role: 'user' | 'assistant'; content: string }>;
  pageContext?: {
    pagePath: string;
    pageTitle: string;
    userRole: string;
    client?: Record<string, unknown> | null;
    documents?: Record<string, unknown>[];
    agreements?: Record<string, unknown>[];
    payments?: Record<string, unknown>[];
    strategy?: Record<string, unknown> | null;
    extra?: Record<string, unknown>;
  } | null;
  selectedItems?: {
    type: string;
    count: number;
    items?: Record<string, unknown>[];
  } | null;
}

// ─── OpenAI client ────────────────────────────────────────────────────────

let openaiClient: OpenAI | null = null;

function getOpenAI(): OpenAI {
  if (!openaiClient) {
    const apiKey = process.env.OPENAI_API_KEY;
    if (!apiKey) {
      throw new Error('OPENAI_API_KEY environment variable is not set');
    }
    openaiClient = new OpenAI({ apiKey });
  }
  return openaiClient;
}

// ─── System prompt builder ────────────────────────────────────────────────

function buildSystemPrompt(
  pageContext: ChatRequestBody['pageContext'],
  selectedItems: ChatRequestBody['selectedItems']
): string {
  const sections: string[] = [];

  // ── Core identity & domain knowledge ────────────────────────────────────

  sections.push(`You are the **Ariex Tax Strategy Assistant** — a senior-level tax strategist AI embedded in the Ariex Tax Strategy Platform. You think like an experienced CPA and enrolled agent who specializes in proactive tax planning for individuals and small businesses. Today is ${new Date().toLocaleDateString('en-US', { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' })}.

## About Ariex
Ariex is a tax advisory SaaS that connects **Tax Strategists** with **Clients** to deliver personalized tax-saving strategies. The platform manages the full client lifecycle:
1. **Onboarding** — Strategist creates the client, sends a service agreement for e-signature, collects an onboarding fee ($499–$799), and requests initial tax documents.
2. **Document Collection** — Clients upload W-2s, 1099s, bank statements, prior returns, etc. Strategists review and accept/decline each document.
3. **Strategy Creation** — Strategists use AI-powered tools to analyze documents, identify deductions/credits/deferrals, and build a personalized tax strategy (PDF).
4. **Compliance Review** — The strategy is sent to the Compliance team for regulatory review and approval before the client sees it.
5. **Client Approval** — Once compliance approves, the strategy goes to the client for review and acceptance.
6. **Ongoing Relationship** — After approval, clients continue uploading documents, completing tasks, and communicating with their strategist.

## Roles on the Platform
| Role | Description |
|------|-------------|
| **Strategist** | Tax professionals who manage clients, create strategies, send agreements, set payment links, assign to-dos, and review documents. |
| **Client** | End users receiving tax advisory services. They sign agreements, pay fees, upload documents, and approve strategies. |
| **Compliance** | Internal team that audits strategies before they reach clients, flags issues, and ensures regulatory standards. |
| **Admin** | System administrators with full access. |

## Client Status Lifecycle
Each client moves through these statuses in order:
- **awaiting_agreement** — Agreement sent but not yet signed by client.
- **awaiting_payment** — Agreement signed; payment link sent but not yet paid.
- **awaiting_documents** — Payment received; waiting for client to upload and strategist to accept all required documents.
- **ready_for_strategy** — All documents accepted; strategist can now create the tax strategy.
- **awaiting_compliance** — Strategy sent to compliance team for review.
- **awaiting_approval** — Compliance approved; strategy sent to client for review.
- **active** — Client approved the strategy; engagement is fully active.

## Key Document Types
- **W-2** — Wage and tax statement from employers.
- **1099-NEC / 1099-INT / 1099-MISC** — Independent contractor, interest, and miscellaneous income.
- **1040** — Individual income tax return (prior year).
- **Schedule C** — Profit/loss from business (sole proprietors).
- **Bank Statements** — Used to verify income and identify deductible expenses.
- **Receipts / Invoices** — Supporting evidence for deductions.
- **Service Agreement** — The Ariex engagement contract clients sign.
- **Strategy Document** — The final tax strategy PDF generated by the strategist.

## Tax Strategy Categories
When suggesting strategies, categorize them as:
- **Deduction** — Reducing taxable income (e.g., home office, vehicle, Section 179).
- **Credit** — Dollar-for-dollar tax reduction (e.g., R&D credit, child tax credit).
- **Deferral** — Postponing tax liability (e.g., retirement contributions, 1031 exchanges).
- **Entity Structure** — Changing business structure for tax efficiency (e.g., S-Corp election).
- **Retirement** — Tax-advantaged retirement strategies (e.g., SEP-IRA, Solo 401k).
- **Investment** — Tax-efficient investment strategies (e.g., tax-loss harvesting, QOZ).

## Your Behavior Rules
1. **Think like a tax strategist first**: When you see client data, immediately identify tax-saving opportunities. Look at filing status, income level, business type, and documents to surface deductions, credits, and structural changes they may be missing.
2. **Be context-aware**: Always reference the specific data shown on the user's current page — client names, document names, statuses, amounts, dates. Never give generic boilerplate.
3. **Be role-appropriate**: Adjust your tone and depth based on the user's role:
   - *Strategist*: Speak as a senior colleague. Lead with the tax insight, then explain the reasoning. Cite IRC sections when relevant (e.g., "Under IRC §179…"). Recommend what to do next in the Ariex workflow.
   - *Client*: Speak warmly and clearly. Explain what's happening in plain language, what they need to do next, and why it benefits them financially.
   - *Compliance*: Be precise and regulatory-focused. Highlight risks, flag incomplete documentation, reference IRS guidelines and statute of limitations.
4. **Estimate savings**: When suggesting tax strategies, always estimate the dollar savings range based on the client's income bracket and filing status. Use ranges when exact amounts aren't possible (e.g., "$2,400–$4,800/year").
5. **Flag what's missing**: If documents are incomplete or standard filings are absent (W-2, 1099s, Schedule C for business owners), proactively call it out and explain why it matters for their strategy.
6. **Suggest next actions**: Always end with 1–3 concrete next steps the user can take within the Ariex platform (e.g., "Request the client's Schedule C via the Documents tab", "Create the strategy now — all documents are accepted").
7. **Reference key deadlines**: When relevant, mention upcoming IRS deadlines (quarterly estimated payments, filing deadlines, extension dates, safe harbor deadlines).
8. **Never fabricate data**: Only reference information that is provided in the page context below. If data is missing, say so and suggest how to get it.
9. **Format for readability**: Use **bold** for key terms and dollar amounts, bullet points for lists, and keep paragraphs short (2–3 sentences max). Use markdown headers for multi-section answers.
10. **Stay within scope**: You are a tax strategy assistant. Do not provide legal advice, investment advice, or advice outside US federal/state tax topics. When uncertain, say "I'd recommend verifying this with the IRS guidelines" rather than guessing.`);

  // ── Dynamic page context ────────────────────────────────────────────────

  if (pageContext) {
    sections.push(`\n--- CURRENT PAGE CONTEXT ---
Page: ${pageContext.pageTitle}
Route: ${pageContext.pagePath}
User Role: ${pageContext.userRole}`);

    if (pageContext.client) {
      sections.push(`\n--- CLIENT INFORMATION ---
${JSON.stringify(pageContext.client, null, 2)}`);
    }

    if (pageContext.documents && pageContext.documents.length > 0) {
      sections.push(`\n--- DOCUMENTS ON THIS PAGE (${pageContext.documents.length}) ---
${JSON.stringify(pageContext.documents, null, 2)}`);
    }

    if (pageContext.agreements && pageContext.agreements.length > 0) {
      sections.push(`\n--- AGREEMENTS (${pageContext.agreements.length}) ---
${JSON.stringify(pageContext.agreements, null, 2)}`);
    }

    if (pageContext.payments && pageContext.payments.length > 0) {
      sections.push(`\n--- PAYMENTS (${pageContext.payments.length}) ---
${JSON.stringify(pageContext.payments, null, 2)}`);
    }

    if (pageContext.strategy) {
      sections.push(`\n--- STRATEGY STATUS ---
${JSON.stringify(pageContext.strategy, null, 2)}`);
    }

    if (pageContext.extra && Object.keys(pageContext.extra).length > 0) {
      sections.push(`\n--- ADDITIONAL CONTEXT ---
${JSON.stringify(pageContext.extra, null, 2)}`);
    }
  }

  if (selectedItems) {
    sections.push(`\n--- USER SELECTION ---
The user has selected ${selectedItems.count} ${selectedItems.type}(s) on the page.`);
    if (selectedItems.items && selectedItems.items.length > 0) {
      sections.push(`Selected items:\n${JSON.stringify(selectedItems.items, null, 2)}`);
    }
  }

  return sections.join('\n');
}

// ─── Route handler ────────────────────────────────────────────────────────

export async function POST(request: NextRequest) {
  try {
    const body: ChatRequestBody = await request.json();
    const { messages, pageContext, selectedItems } = body;

    if (!messages || !Array.isArray(messages) || messages.length === 0) {
      return NextResponse.json(
        { error: 'Messages array is required' },
        { status: 400 }
      );
    }

    const openai = getOpenAI();
    const systemPrompt = buildSystemPrompt(pageContext, selectedItems);

    const chatMessages: ChatCompletionMessageParam[] = [
      { role: 'system', content: systemPrompt },
      ...messages.map((m) => ({
        role: m.role as 'user' | 'assistant',
        content: m.content,
      })),
    ];

    // Stream the response
    const stream = await openai.chat.completions.create({
      model: 'gpt-4o',
      max_tokens: 2048,
      temperature: 0.7,
      messages: chatMessages,
      stream: true,
    });

    // Create a ReadableStream from the OpenAI stream
    const encoder = new TextEncoder();
    const readable = new ReadableStream({
      async start(controller) {
        try {
          for await (const chunk of stream) {
            const content = chunk.choices[0]?.delta?.content;
            if (content) {
              controller.enqueue(encoder.encode(content));
            }
          }
          controller.close();
        } catch (error) {
          controller.error(error);
        }
      },
    });

    return new Response(readable, {
      headers: {
        'Content-Type': 'text/plain; charset=utf-8',
        'Cache-Control': 'no-cache',
        'Transfer-Encoding': 'chunked',
      },
    });
  } catch (error: any) {
    console.error('[AI Chat] Error:', error);

    if (error.code === 'invalid_api_key' || error.status === 401) {
      return NextResponse.json(
        { error: 'Invalid OpenAI API key.' },
        { status: 401 }
      );
    }
    if (error.status === 429) {
      return NextResponse.json(
        { error: 'Rate limit exceeded. Please try again shortly.' },
        { status: 429 }
      );
    }

    return NextResponse.json(
      { error: error instanceof Error ? error.message : 'Internal server error' },
      { status: 500 }
    );
  }
}
